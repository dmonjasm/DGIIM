Para este algoritmo hemos creado un struct nodo cuyo contenido es, un puntero a un nodo padre, una puntero a punteros con el que se quiere conseguir apuntar a un array de punteros de nodos, una cota inferior y una cota superior, una ciudad, el número de hijos de dicho nodo, las ciudades restantes de ese nodo.

Para la función que realiza el branch_and_bound le pasamos como parámetros, el nodo actual sobre el que trabajaremos, un multimap ramificación que es el contenedor utilizado para almacenar con prioridades cual será el siguiente nodo sobre el que se va a trabajar, una matriz de double que contiene las distancias entre las ciudades, un nodo salida que una vez termine el algoritmo contendrá la información del nodo de nivel más inferior y con menor distancia en su recorrido, un contador de podas, un contador de tamaño máximo de ramificación(cola con prioridad) y un contador de los nodos que se expanden.

En el main creamos dos nodos, uno será el nodo raíz y contendrá la ciudad 1 y como ciudades restantes todas las ciudades menos ella misma, también se crea el nodo salida que solamente almacena cota superior y cota inferior que serán ambas iguales y contendrán el valor obtenido por inserción_milindrona. Insertamos el nodo raíz en la cola con prioridad y se inicia el algoritmo. Si el vector de ciudades restantes asociado al nodo actual es no vacío entonces se crean los hijos de dicho nodo, un hijo por ciudad restante y se actualiza el contador de nodos expandidos. Se esparce la cota superior (distancia obtenida por inserción milindrona) a todos los nodos hijos y se elimina el nodo actual de la cola con prioridad pues ya se ha trabajado con el. Entonces para cada hijo se establece su vector de ciudades restantes, tomando el vector ciudades restantes del padre y eliminando el elemento del vector que sea igual a la ciudad que almacena el hijo. Una vez hecho esto le vamos a calcular la cota inferior al hijo y distinguimos dos casos. Si tiene ciudades en el vector de ciudades restantes, entonces la cota inferior será la distancia acumulada desde el nodo raiz hasta el hijo actual más la minima distancia del nodo actual a una de las ciudades de ciudades restantes, y se almacena en la cola con prioridad el nodo y la distancia minima de la ciudad que almacena, a una de ciudades restante (la prioridad viene dada en función de esta distancia mínima, pues cuanto menor sea esta más arriba está en la cola, lo hemos implementado con un multimap<double, nodo *>). Si ciudades restantes está vacío la cota inferior será la distancia total acumulada desde raíz hasta el hijo actual. Ahora si no quedan ciudades en el vector ciudades restantes significa que ese arbol ha llegado a un nodo hoja, luego se crea un nodo hijo para este nodo hoja y se le establece como ciudad la ciudad 1 que es la inicial con lo que cerramos el circuito, actualizamos la cota inferior y si esta es menor que la cota inferior de salida se actualiza salida igualandola a este nodo. Después también se comprueba si hay que podar un nodo, luego si la cota inferior de un nodo es mayor que la cota superior del mismo (igual en todos los nodos) este se podará y se sumará uno al contador de podas. Una vez se ha realizado esto para todos los nodos hijos se comprueba si el tamaño actual de la ramificación es mayor que el máximo que se tenía almacenado y en caso de que lo sea se actualiza. Luego si la cola con prioridad no está vacía se comprueba si el nodo con mayor prioridad está podado y si lo está lo elimina, así hasta encontrar un nodo no podado. Finalmente se llama recursivamente a la función pasandole como nodo sobre el que trabajar el primer de la cola de prioridad, la cola de prioridad, la matriz de distancia y los contadores de podas, tamaño máximo de la cola de prioridad y nodos expandidos.

Una vez terminada la ejecución del algoritmo nos queda en nodo salida un nodo del nivel más inferior, tal que si ascendemos por sus padres hasta llegar al nodo raíz obtenemos el circiuto de menor distancia. En la variables contadores tendremos almacenados el número total de podas, el tamaño máximo de la cola con prioridad y el número de nodos expandidos.
